# TrainSQL 原理介绍

> 由 Golang 实现的支持**事务**及 **MVCC** 特性的简易 SQL 数据库
> 
> 存储层采用 **BitCask** 模型的 KV 存储引擎, 因此以下所有的key都将全量在内存中, 并且不同的key升序排序,相同的key按照版本号升序排序;

---

## 📐 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                      SQL Layer                          │
│  ┌─────────┐  ┌────────┐  ┌──────┐  ┌──────────────┐    │
│  │  Lexer  │→ │ Parser │→ │ Plan │→ │   Executor   │    │
│  └─────────┘  └────────┘  └──────┘  └──────────────┘    │
├─────────────────────────────────────────────────────────┤
│                   Transaction Layer                     │
│  ┌─────────────────┐  ┌──────────────────────────────┐  │
│  │ Transaction Mgr │  │    MVCC (Multi-Version)      │  │
│  └─────────────────┘  └──────────────────────────────┘  │
├─────────────────────────────────────────────────────────┤
│                    Storage Layer                        │
│  ┌──────────────────────────────────────────────────┐   │
│  │              BitCask KV Engine                   │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

---

## 🗃️ 数据结构

### 1. 行数据存储

每条记录的 KV 存储结构：

```
Key:   Row_<tableName>_<primaryVal>
Value: [col1, col2, col3, ...]
```

**示例**：
```
Key:   Row_user_1
Value: [1, "张三", 25, "北京"]
含义:  user 表中主键为 1 的记录
```

---

### 2. 表元数据存储

表定义信息的 KV 存储结构：

```
Key:   Table_<tableName>
Value: [列定义信息...]
```

**示例**：
```
Key:   Table_user
Value: [{name:"id", type:INT, pk:true}, {name:"name", type:VARCHAR}, ...]
含义:  user 表的 Schema 定义
```

---

### 3. 索引存储

二级索引的 KV 存储结构：

```
Key:   Index_<tableName>_<colName>_<colVal>
Value: [primaryKey1, primaryKey2, ...]  // 主键集合，需回表查询
```

**示例**：
```
Key:   Index_user_name_zhangsan
Value: [1, 5, 12]
含义:  user 表中 name="zhangsan" 的记录主键集合
```

---

### 4. 完整示例

假设有 `user` 表，主键为 `a`，索引列为 `b`：

| a (PK) | b (Index) | c | d |
|:------:|:---------:|:---:|:---:|
| 1 | 22 | 33 | 44 |
| 2 | 33 | 44 | 55 |
| 3 | 22 | 55 | 66 |
| 4 | 55 | 66 | 78 |
| 5 | 55 | 66 | 77 |

**KV 存储映射**：

```bash
# 表元数据
Table_user           → [a, b, c, d]

# 行数据 (按主键存储)
Row_user_1           → [1, 22, 33, 44]
Row_user_2           → [2, 33, 44, 55]
Row_user_3           → [3, 22, 55, 66]
Row_user_4           → [4, 55, 66, 78]
Row_user_5           → [5, 55, 66, 77]

# 索引数据 (按索引值分组)
Index_user_b_22      → [1, 3]      # b=22 的主键集合
Index_user_b_33      → [2]         # b=33 的主键集合
Index_user_b_55      → [4, 5]      # b=55 的主键集合
```

> 📝 **注意**：上述类型的 Key 统称为 `dataKey`，在后续事务和 MVCC 章节中会用到。

---

## 🔄 事务实现

### 事务相关的存储结构

#### 1. 全局事务版本号

```
Key:   NextVersion
Value: uint64 (下一个可用的事务版本号)
```

- 每个新事务启动时，原子性地获取并自增此值
- 并发访问需加锁，保证版本号唯一递增

---

#### 2. 活跃事务列表

```
Key:   ActiveTxn_<version>
Value: nil
```

**设计目的**：
- 前缀 `ActiveTxn_` 便于范围扫描
- 获取所有活跃事务只需扫描该前缀
- 事务提交/回滚后删除对应记录

**示例**：
```bash
ActiveTxn_100        # 事务 100 正在执行
ActiveTxn_101        # 事务 101 正在执行
ActiveTxn_103        # 事务 103 正在执行
```

---

#### 3. 事务写操作记录

```
Key:   TxnWrite_<version(8字节)>_<dataKey>
Value: nil
```

**设计目的**：
- 记录事务修改了哪些数据
- 前缀扫描 `TxnWrite_<version>_` 可获取事务的所有修改
- 用于提交确认或回滚恢复

**示例**：
```bash
TxnWrite_00000100_Row_user_1     # 事务 100 修改了 Row_user_1
TxnWrite_00000100_Row_user_3     # 事务 100 修改了 Row_user_3
```

---

### 事务操作流程

#### ✅ 提交 (Commit)

```
1. 删除活跃事务记录
   DELETE ActiveTxn_<version>

2. 前缀扫描获取所有修改记录
   SCAN TxnWrite_<version>_*

3. 逐个删除修改记录 (保留实际数据)
   DELETE TxnWrite_<version>_<dataKey>
```

#### ❌ 回滚 (Rollback)

```
1. 删除活跃事务记录
   DELETE ActiveTxn_<version>

2. 前缀扫描获取所有修改记录
   SCAN TxnWrite_<version>_*

3. 从修改记录中提取 dataKey，删除实际数据
   DELETE KeyVersion_<dataKey>_<version>

4. 删除修改记录
   DELETE TxnWrite_<version>_<dataKey>
```

---

## 🔀 MVCC 多版本并发控制

### 多版本数据存储结构

```
Key:   KeyVersion_<dataKey>_<version>
Value: [实际数据...]
```

**设计目的**：
- 同一 `dataKey` 可存在多个版本
- 前缀扫描 `KeyVersion_<dataKey>_` 可获取所有历史版本
- 根据事务可见性规则选择合适版本

**示例**：
```bash
KeyVersion_Row_user_1_100    → [1, "张三", 25]   # 版本 100
KeyVersion_Row_user_1_105    → [1, "张三", 26]   # 版本 105
KeyVersion_Row_user_1_110    → [1, "李四", 26]   # 版本 110
```

---

### 写操作流程

```
写入 dataKey (当前事务版本: V)
         │
         ▼
┌─────────────────────────────┐
│  查询 dataKey 的最新版本 Vn   │
└─────────────────────────────┘
         │
         ▼
┌─────────────────────────────┐
│  Vn 在活跃事务列表中?         │
└─────────────────────────────┘
         │
    ┌────┴────┐
    │ Yes     │ No
    ▼         ▼
┌───────┐  ┌─────────────────┐
│写冲突  │  │  Vn <= V ?      │
└───────┘  └─────────────────┘
               │
          ┌────┴────┐
          │ Yes     │ No
          ▼         ▼
     ┌────────┐  ┌───────┐
     │写入成功 │  │写冲突  │
     └────────┘  └───────┘
```

**写入规则**：
1. 如果 `dataKey` 的最新版本属于**活跃事务** → 写冲突
2. 如果最新版本号 **> 当前事务版本** → 写冲突
3. 否则，写入成功，存储为 `KeyVersion_<dataKey>_<version>`

---

### 读操作流程

```
读取 dataKey (当前事务版本: V)
         │
         ▼
┌──────────────────────────────────────┐
│  范围扫描:                            │
│  FROM: KeyVersion_<dataKey>_0        │
│  TO:   KeyVersion_<dataKey>_<V+1>    │
└──────────────────────────────────────┘
         │
         ▼
┌──────────────────────────────────────┐
│  逆序遍历结果 (从高版本到低版本)        │
│  判断版本是否对当前事务可见             │
└──────────────────────────────────────┘
         │
         ▼
    返回第一个可见版本的数据
```

**可见性规则**：
- 版本号 <= 当前事务版本
- 版本对应的事务已提交 (不在活跃事务列表中)

---

## 📊 存储 Key 类型汇总

| 前缀 | 格式 | 用途 |
|:-----|:-----|:-----|
| `Table_` | `Table_<tableName>` | 表元数据 |
| `Row_` | `Row_<tableName>_<pk>` | 行数据标识 |
| `Index_` | `Index_<table>_<col>_<val>` | 二级索引 |
| `NextVersion` | `NextVersion` | 全局事务版本号 |
| `ActiveTxn_` | `ActiveTxn_<version>` | 活跃事务记录 |
| `TxnWrite_` | `TxnWrite_<version>_<dataKey>` | 事务写记录 |
| `KeyVersion_` | `KeyVersion_<dataKey>_<version>` | MVCC 多版本数据 |
